#!/bin/sh

# Wiretide Agent (Hybrid + Hostname Debug Logging)
# - Cross-matches Wi-Fi and ARP clients with /tmp/dhcp.leases
# - Logs all DHCP MAC→hostname pairs
# - Logs every client and whether it matched DHCP
# - Normalizes all MACs (lowercase)
# - Avoids subshells (CLIENTS builds correctly)

CONTROLLER_URL="$(cat /etc/wiretide-controller 2>/dev/null || echo 'https://127.0.0.1')"
CA_CERT="/etc/wiretide-ca.crt"
TOKEN_FILE="/etc/wiretide-token"
INTERVAL=60
POLL_DELAY=10
DEBUG_LOG="/tmp/wiretide-debug.log"
PAYLOAD_FILE="/tmp/wiretide-last-payload.json"
DHCP_DEBUG="/tmp/wiretide-hostname-debug.txt"

# Primary interface + MAC
IFACE=""
[ -d /sys/class/net/br-lan ] && IFACE="br-lan"
[ -z "$IFACE" ] && IFACE="$(ip route | awk '/default/ {print $5}' | head -n1)"
[ -z "$IFACE" ] && IFACE="$(ip -o link show | awk -F': ' '/state UP/ && $2!="lo"{print $2;exit}')"
MAC="$(ip link show "$IFACE" 2>/dev/null | awk '/ether/ {print tolower($2)}')"
DEVICE_IP="$(ip -4 addr show "$IFACE" 2>/dev/null | awk '/inet /{print $2}' | cut -d/ -f1)"
MODEL="$(cat /tmp/sysinfo/model 2>/dev/null)"
FPR="$(dropbearkey -y -f /etc/dropbear/dropbear_rsa_host_key 2>/dev/null | awk -F': ' '/Fingerprint/ {print $2}')"

HOSTNAME="$(uci get system.@system[0].hostname 2>/dev/null || hostname 2>/dev/null)"
[ -z "$HOSTNAME" ] && HOSTNAME="$MAC"

log() {
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >> "$DEBUG_LOG"
}

normalize_mac() {
  echo "$1" | tr 'A-F' 'a-f'
}

# Lookup DHCP entry (returns "IP,Hostname" or empty)
lookup_dhcp() {
  mac="$(normalize_mac "$1")"
  awk -v mac="$mac" 'tolower($2)==mac {hn=$4; if(hn=="*"||hn=="")hn="unknown"; print $3","hn; exit}' /tmp/dhcp.leases 2>/dev/null
}

find_interface() {
  mac="$(normalize_mac "$1")"
  for ifc in $(iw dev 2>/dev/null | awk '/Interface/{print $2}'); do
    iw dev "$ifc" station dump 2>/dev/null | grep -qi "$mac" && { echo "$ifc"; return; }
  done
  brctl showmacs br-lan 2>/dev/null | awk -v mac="$mac" '{print tolower($1)}' | grep -q "$mac" && { echo "br-lan"; return; }
  echo "unknown"
}

build_payload() {
  SSH_ENABLED=false
  pgrep dropbear >/dev/null && [ -s /etc/dropbear/dropbear_rsa_host_key ] && SSH_ENABLED=true

  # DNS servers
  DNS_RAW="$(uci get dhcp.@dnsmasq[0].server 2>/dev/null || grep '^nameserver' /tmp/resolv.conf | awk '{print $2}')"
  DNS_LIST=""
  for ip in $DNS_RAW; do
    ip="$(echo "$ip" | tr -d '"')"
    [ -n "$DNS_LIST" ] && DNS_LIST="$DNS_LIST, \"$ip\"" || DNS_LIST="\"$ip\""
  done

  /etc/init.d/firewall enabled && /etc/init.d/firewall status >/dev/null && FIREWALL=true || FIREWALL=false
  NTP="$(uci get system.ntp.enabled 2>/dev/null || echo false)"

  CLIENTS=""
  SEEN="/tmp/wt-seen-macs"; > "$SEEN"

  # Dump all DHCP leases (for debugging)
  awk '{printf "DHCP: MAC=%s HOST=%s\n", tolower($2), $4}' /tmp/dhcp.leases > "$DHCP_DEBUG"

  add_client() {
    mac="$(normalize_mac "$1")"; ip="$2"; hn="$3"; ifc="$4"; via="$5"
    echo "$mac" | grep -Eq '^([0-9a-f]{2}:){5}[0-9a-f]{2}$' || return
    [ -n "$CLIENTS" ] && CLIENTS="$CLIENTS,"
    CLIENTS="$CLIENTS{ \"mac\":\"$mac\",\"ip\":\"$ip\",\"hostname\":\"$hn\",\"interface\":\"$ifc\",\"connected_via\":\"$via\",\"rx_bytes\":0,\"tx_bytes\":0 }"
    if [ "$hn" != "unknown" ]; then
      log "Added client (DHCP hostname): MAC=$mac IP=$ip Hostname=$hn IF=$ifc Via=$via"
    else
      log "Added client (no hostname): MAC=$mac IP=$ip Hostname=unknown IF=$ifc Via=$via"
    fi
  }

  # Wi-Fi stations (cross-match with DHCP)
  for ifc in $(iw dev 2>/dev/null | awk '/Interface/{print $2}'); do
    for sta in $(iw dev "$ifc" station dump | awk '/Station/{print $2}' | tr 'A-Z' 'a-z'); do
      echo "$sta" >> "$SEEN"
      entry="$(lookup_dhcp "$sta")"
      ip="unknown"; hn="unknown"
      [ -n "$entry" ] && { ip="$(echo "$entry" | cut -d, -f1)"; hn="$(echo "$entry" | cut -d, -f2)"; }
      add_client "$sta" "$ip" "$hn" "$ifc" "wifi"
    done
  done

  # DHCP leases (Ethernet, direct)
  if [ -f /tmp/dhcp.leases ]; then
    while read -r exp mac ip hostname cid; do
      cm="$(normalize_mac "$mac")"
      grep -q "$cm" "$SEEN" && continue
      echo "$cm" >> "$SEEN"
      [ "$hostname" = "*" ] || [ -z "$hostname" ] && hostname="unknown"
      ifc="$(find_interface "$cm")"
      add_client "$cm" "$ip" "$hostname" "$ifc" "ethernet"
    done < /tmp/dhcp.leases
  fi

  # ARP neighbors (cross-match with DHCP)
  while read -r ip dev ll mac rest; do
    cm="$(normalize_mac "$mac")"
    echo "$ip" | grep -q '^fe80::' && continue
    grep -q "$cm" "$SEEN" && continue
    echo "$cm" >> "$SEEN"
    entry="$(lookup_dhcp "$cm")"
    hn="unknown"
    [ -n "$entry" ] && hn="$(echo "$entry" | cut -d, -f2)"
    ifc="$(find_interface "$cm")"
    add_client "$cm" "$ip" "$hn" "$ifc" "ethernet"
  done <<EOF
$(ip neigh show)
EOF

  rm -f "$SEEN"

  SETTINGS=$(cat <<EOF
{ "model":"$MODEL","wan_ip":"$DEVICE_IP","dns":[ $DNS_LIST ],"firewall":$FIREWALL,"ntp":$NTP }
EOF
)

  cat <<EOF > "$PAYLOAD_FILE"
{
  "hostname":"$HOSTNAME",
  "mac":"$MAC",
  "ssh_fingerprint":"$FPR",
  "ssh_enabled":$SSH_ENABLED,
  "settings":$SETTINGS,
  "clients":[ $CLIENTS ]
}
EOF
}

register_device() {
  SSH_ENABLED=false
  pgrep dropbear >/dev/null && [ -s /etc/dropbear/dropbear_rsa_host_key ] && SSH_ENABLED=true
  JSON="{\"hostname\":\"$HOSTNAME\",\"mac\":\"$MAC\",\"ssh_fingerprint\":\"$FPR\",\"ssh_enabled\":$SSH_ENABLED}"
  log "Registering device (hostname: $HOSTNAME)"
  curl --cacert "$CA_CERT" -s -X POST "$CONTROLLER_URL/register" \
       -H "Content-Type: application/json" -d "$JSON" >/dev/null 2>&1
}

fetch_token() {
  log "Requesting token for MAC: $MAC"
  RESPONSE="$(curl --path-as-is --cacert "$CA_CERT" -s -w '\n%{http_code}' "$CONTROLLER_URL/token/$MAC")"
  BODY="$(printf '%s\n' "$RESPONSE" | head -n1)"
  CODE="$(printf '%s\n' "$RESPONSE" | tail -n1)"
  log "Token HTTP code: $CODE"
  log "Token body: $BODY"
  if [ "$CODE" = "200" ]; then
    TOKEN="$(echo "$BODY" | grep -oE '"token"\s*:\s*"[^"]+"' | sed -E 's/.*"token"\s*:\s*"([^"]+)".*/\1/')"
    log "Parsed token: '$TOKEN'"
    if [ -n "$TOKEN" ]; then
      echo "$TOKEN" > "$TOKEN_FILE"; chmod 600 "$TOKEN_FILE"
      log "Token saved"
    else
      log "Empty token – will retry"; rm -f "$TOKEN_FILE"
    fi
  else
    log "Token fetch failed, waiting..."; rm -f "$TOKEN_FILE"
  fi
}

send_status() {
  [ ! -f "$TOKEN_FILE" ] && return 1
  TOKEN="$(cat "$TOKEN_FILE")"
  log "Sending status update..."
  build_payload
  HTTP_CODE=$(curl --cacert "$CA_CERT" -s -o /dev/null -w '%{http_code}' \
               -H "X-API-Token: $TOKEN" \
               -H "Content-Type: application/json" \
               -X POST "$CONTROLLER_URL/status" \
               -d @"$PAYLOAD_FILE")
  log "Status update response: HTTP $HTTP_CODE"
  if [ "$HTTP_CODE" = "403" ]; then
    log "Token invalid – clearing and refetching"
    rm -f "$TOKEN_FILE"
  elif [ "$HTTP_CODE" != "200" ]; then
    log ">>> Payload causing failure:"
    log "$(cat "$PAYLOAD_FILE")"
  fi
}

log "Starting Wiretide agent (Controller: $CONTROLLER_URL, MAC: $MAC)"

register_device

while [ ! -f "$TOKEN_FILE" ]; do
  fetch_token
  [ -f "$TOKEN_FILE" ] || sleep "$POLL_DELAY"
done

while true; do
  send_status
  if [ ! -f "$TOKEN_FILE" ]; then
    while [ ! -f "$TOKEN_FILE" ]; do
      fetch_token
      [ -f "$TOKEN_FILE" ] || sleep "$POLL_DELAY"
    done
  fi
  sleep "$INTERVAL"
done

