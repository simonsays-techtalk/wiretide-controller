#!/bin/sh

# Wiretide Agent (Hybrid + Hostname Debug Logging + Task Execution + Firewall/Security Logging Support)
VERSION="Wiretide Agent v2025.08.08+fwsec"

# Kill any other running copies (self-cleanup)
for pid in $(ps w | grep '[w]iretide-agent-run' | awk '{print $1}'); do
    [ "$pid" != "$$" ] && kill -9 "$pid" 2>/dev/null
done

echo "[$(date '+%Y-%m-%d %H:%M:%S')] Starting $VERSION (PID $$)" >> /tmp/wiretide-debug.log

CONTROLLER_URL="$(cat /etc/wiretide-controller 2>/dev/null || echo 'https://127.0.0.1')"
CA_CERT="/etc/wiretide-ca.crt"
TOKEN_FILE="/etc/wiretide-token"
INTERVAL=60
POLL_DELAY=10
DEBUG_LOG="/tmp/wiretide-debug.log"
PAYLOAD_FILE="/tmp/wiretide-last-payload.json"
DHCP_DEBUG="/tmp/wiretide-hostname-debug.txt"

NOW_YEAR="$(date +%Y)"
if [ "$NOW_YEAR" -lt 2020 ]; then
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] ⚠️  System clock appears invalid (year: $NOW_YEAR), TLS may fail" >> "$DEBUG_LOG"
fi

IFACE=""
[ -d /sys/class/net/br-lan ] && IFACE="br-lan"
[ -z "$IFACE" ] && IFACE="$(ip route | awk '/default/ {print $5}' | head -n1)"
[ -z "$IFACE" ] && IFACE="$(ip -o link show | awk -F': ' '/state UP/ && $2!="lo"{print $2;exit}')"
MAC="$(ip link show "$IFACE" 2>/dev/null | awk '/ether/ {print tolower($2)}')"
DEVICE_IP="$(ip -4 addr show "$IFACE" 2>/dev/null | awk '/inet /{print $2}' | cut -d/ -f1)"
MODEL="$(cat /tmp/sysinfo/model 2>/dev/null)"
FPR="$(dropbearkey -y -f /etc/dropbear/dropbear_rsa_host_key 2>/dev/null | awk -F': ' '/Fingerprint/ {print $2}')"
HOSTNAME="$(uci get system.@system[0].hostname 2>/dev/null || hostname 2>/dev/null)"
[ -z "$HOSTNAME" ] && HOSTNAME="$MAC"

log() {
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >> "$DEBUG_LOG"
}

normalize_mac() {
  echo "$1" | tr 'A-F' 'a-f'
}

lookup_dhcp() {
  mac="$(normalize_mac "$1")"
  awk -v mac="$mac" 'tolower($2)==mac {hn=$4; if(hn=="*"||hn=="")hn="unknown"; print $3","hn; exit}' /tmp/dhcp.leases 2>/dev/null
}

find_interface() {
  mac="$(normalize_mac "$1")"
  for ifc in $(iw dev 2>/dev/null | awk '/Interface/{print $2}'); do
    iw dev "$ifc" station dump 2>/dev/null | grep -qi "$mac" && { echo "$ifc"; return; }
  done
  brctl showmacs br-lan 2>/dev/null | awk -v mac="$mac" '{print tolower($1)}' | grep -q "$mac" && { echo "br-lan"; return; }
  echo "unknown"
}

sha256_json() {
  echo "$1" | jq -S -c . | sed 's/: /:/g' | tr -d '\n' | sha256sum | awk '{print $1}'
}

build_payload() {
  SSH_ENABLED=false
  pgrep dropbear >/dev/null && [ -s /etc/dropbear/dropbear_rsa_host_key ] && SSH_ENABLED=true

  DNS_RAW="$(uci get dhcp.@dnsmasq[0].server 2>/dev/null || grep '^nameserver' /tmp/resolv.conf | awk '{print $2}')"
  DNS_LIST=""
  for ip in $DNS_RAW; do
    ip="$(echo "$ip" | tr -d '"')"
    [ -n "$DNS_LIST" ] && DNS_LIST="$DNS_LIST, \"$ip\"" || DNS_LIST="\"$ip\""
  done

  /etc/init.d/firewall enabled && /etc/init.d/firewall status >/dev/null && FIREWALL=true || FIREWALL=false
  NTP="$(uci get system.ntp.enabled 2>/dev/null || echo false)"

  # Nieuw: actieve firewall-profiel en logprefix uitlezen
  ACTIVE_PROFILE="$(cat /etc/wiretide/fw_active_profile 2>/dev/null)"
  LOG_PREF="$(cat /etc/wiretide/fw_log_prefix 2>/dev/null || echo WTSEC)"
  # Laatste 20 regels security logs
  SEC_LINES="$(logread -l 200 2>/dev/null | grep "$LOG_PREF" | tail -n 20 | sed 's/"/\\"/g')"
  SEC_JSON="$(printf '%s\n' "$SEC_LINES" | awk 'BEGIN{print "["}{gsub(/\r/,""); printf (NR>1?",":""); printf "\"%s\"", $0} END{print "]"}')"

  CLIENTS=""
  SEEN="/tmp/wt-seen-macs"; > "$SEEN"
  awk '{printf "DHCP: MAC=%s HOST=%s\n", tolower($2), $4}' /tmp/dhcp.leases > "$DHCP_DEBUG"

  add_client() {
    mac="$(normalize_mac "$1")"; ip="$2"; hn="$3"; ifc="$4"; via="$5"
    echo "$mac" | grep -Eq '^([0-9a-f]{2}:){5}[0-9a-f]{2}$' || return
    [ -n "$CLIENTS" ] && CLIENTS="$CLIENTS,"
    CLIENTS="$CLIENTS{ \"mac\":\"$mac\",\"ip\":\"$ip\",\"hostname\":\"$hn\",\"interface\":\"$ifc\",\"connected_via\":\"$via\",\"rx_bytes\":0,\"tx_bytes\":0 }"
    [ "$hn" != "unknown" ] && log "Added client (DHCP hostname): MAC=$mac IP=$ip Hostname=$hn IF=$ifc Via=$via" || \
      log "Added client (no hostname): MAC=$mac IP=$ip Hostname=unknown IF=$ifc Via=$via"
  }

  for ifc in $(iw dev 2>/dev/null | awk '/Interface/{print $2}'); do
    for sta in $(iw dev "$ifc" station dump | awk '/Station/{print $2}' | tr 'A-Z' 'a-z'); do
      echo "$sta" >> "$SEEN"
      entry="$(lookup_dhcp "$sta")"
      ip="unknown"; hn="unknown"
      [ -n "$entry" ] && { ip="$(echo "$entry" | cut -d, -f1)"; hn="$(echo "$entry" | cut -d, -f2)"; }
      add_client "$sta" "$ip" "$hn" "$ifc" "wifi"
    done
  done

  if [ -f /tmp/dhcp.leases ]; then
    while read -r exp mac ip hostname cid; do
      cm="$(normalize_mac "$mac")"
      grep -q "$cm" "$SEEN" && continue
      echo "$cm" >> "$SEEN"
      [ "$hostname" = "*" ] || [ -z "$hostname" ] && hostname="unknown"
      ifc="$(find_interface "$cm")"
      add_client "$cm" "$ip" "$hostname" "$ifc" "ethernet"
    done < /tmp/dhcp.leases
  fi

  while read -r ip dev ll mac rest; do
    cm="$(normalize_mac "$mac")"
    echo "$ip" | grep -q '^fe80::' && continue
    grep -q "$cm" "$SEEN" && continue
    echo "$cm" >> "$SEEN"
    entry="$(lookup_dhcp "$cm")"
    hn="unknown"
    [ -n "$entry" ] && hn="$(echo "$entry" | cut -d, -f2)"
    ifc="$(find_interface "$cm")"
    add_client "$cm" "$ip" "$hn" "$ifc" "ethernet"
  done <<EOF
$(ip neigh show)
EOF

  rm -f "$SEEN"

  SETTINGS=$(cat <<EOF
{ "model":"$MODEL",
  "wan_ip":"$DEVICE_IP",
  "dns":[ $DNS_LIST ],
  "firewall":$FIREWALL,
  "ntp":$NTP,
  "firewall_profile":"$ACTIVE_PROFILE",
  "fw_log_prefix":"$LOG_PREF",
  "security_log_samples":$SEC_JSON }
EOF
)

  cat <<EOF > "$PAYLOAD_FILE"
{
  "hostname":"$HOSTNAME",
  "mac":"$MAC",
  "ssh_fingerprint":"$FPR",
  "ssh_enabled":$SSH_ENABLED,
  "settings":$SETTINGS,
  "clients":[ $CLIENTS ]
}
EOF
}

register_device() {
  SSH_ENABLED=false
  pgrep dropbear >/dev/null && [ -s /etc/dropbear/dropbear_rsa_host_key ] && SSH_ENABLED=true
  JSON="{\"hostname\":\"$HOSTNAME\",\"mac\":\"$MAC\",\"ssh_fingerprint\":\"$FPR\",\"ssh_enabled\":$SSH_ENABLED}"
  log "Registering device (hostname: $HOSTNAME)"
  curl --cacert "$CA_CERT" -s -X POST "$CONTROLLER_URL/register" \
       -H "Content-Type: application/json" -d "$JSON" >/dev/null 2>&1
}

fetch_token() {
  log "Requesting token for MAC: $MAC"
  RESPONSE="$(curl --path-as-is --cacert "$CA_CERT" -s -w '\n%{http_code}' "$CONTROLLER_URL/token/$MAC")"
  BODY="$(printf '%s\n' "$RESPONSE" | head -n1)"
  CODE="$(printf '%s\n' "$RESPONSE" | tail -n1)"
  log "Token HTTP code: $CODE"
  log "Token body: $BODY"
  if [ "$CODE" = "200" ]; then
    TOKEN="$(echo "$BODY" | grep -oE '"token"\s*:\s*"[^"]+"' | sed -E 's/.*"token"\s*:\s*"([^"]+)".*/\1/')"
    log "Parsed token: '$TOKEN'"
    if [ -n "$TOKEN" ]; then
      echo "$TOKEN" > "$TOKEN_FILE"; chmod 600 "$TOKEN_FILE"
      log "Token saved"
    else
      log "Empty token – will retry"; rm -f "$TOKEN_FILE"
    fi
  else
    log "Token fetch failed, waiting..."; rm -f "$TOKEN_FILE"
  fi
}

send_status() {
  [ ! -f "$TOKEN_FILE" ] && return 1
  TOKEN="$(cat "$TOKEN_FILE")"
  log "Sending status update..."
  build_payload
  HTTP_CODE=$(curl --cacert "$CA_CERT" -s -o /dev/null -w '%{http_code}' \
               -H "X-API-Token: $TOKEN" \
               -H "Content-Type: application/json" \
               -X POST "$CONTROLLER_URL/status" \
               -d @"$PAYLOAD_FILE")
  log "Status update response: HTTP $HTTP_CODE"
  if [ "$HTTP_CODE" = "403" ]; then
    log "Token invalid – clearing and refetching"
    rm -f "$TOKEN_FILE"
  elif [ "$HTTP_CODE" != "200" ]; then
    log ">>> Payload causing failure:"
    log "$(cat "$PAYLOAD_FILE")"
  fi
}

handle_package() {
  [ ! -f "$TOKEN_FILE" ] && return
  TOKEN="$(cat "$TOKEN_FILE")"
  RESPONSE="$(curl --cacert "$CA_CERT" -s -H "X-API-Token: $TOKEN" -H "X-MAC: $MAC" "$CONTROLLER_URL/config")"
  PKG_JSON="$(echo "$RESPONSE" | jq -c '.package')"
  EXPECTED="$(echo "$RESPONSE" | jq -r '.sha256')"

  if [ "$PKG_JSON" = "{}" ] || [ -z "$EXPECTED" ]; then
    return
  fi

  ACTUAL="$(sha256_json "$PKG_JSON")"
  if [ "$EXPECTED" != "$ACTUAL" ]; then
    log "Package SHA256 mismatch (expected $EXPECTED, got $ACTUAL)"
    return
  fi

  log "Executing config package..."

  FIREWALL_PROFILE="$(echo "$PKG_JSON" | jq -r '.firewall_profile // empty')"
  if [ -n "$FIREWALL_PROFILE" ]; then
    FILE="/etc/wiretide/profiles/firewall-$FIREWALL_PROFILE.conf"
    EXPECTED_HASH="$(echo "$RESPONSE" | jq -r '.package_hashes.firewall_profile // empty')"
    if [ -n "$EXPECTED_HASH" ]; then
      ACTUAL_HASH="$(sha256sum "$FILE" 2>/dev/null | awk '{print $1}')"
      if [ "$EXPECTED_HASH" != "$ACTUAL_HASH" ]; then
        log "Firewall profile hash mismatch ($FIREWALL_PROFILE)"
        return
      fi
    fi
    if [ -f "$FILE" ]; then
      cp "$FILE" /etc/config/firewall
      /etc/init.d/firewall restart
      mkdir -p /etc/wiretide
      echo "$FIREWALL_PROFILE" > /etc/wiretide/fw_active_profile
      log "Applied profile: $FIREWALL_PROFILE"
    else
      log "Missing profile: $FIREWALL_PROFILE"
    fi
  fi

  # Nieuw: Security logging
  SEC_LOG="$(echo "$PKG_JSON" | jq -c '.security_logging // {}')"
  if echo "$SEC_LOG" | jq -e 'to_entries | length > 0' >/dev/null 2>&1; then
    EN=$(echo "$SEC_LOG" | jq -r '.enabled // false')
    LVL=$(echo "$SEC_LOG" | jq -r '.level // "info"')
    PFX=$(echo "$SEC_LOG" | jq -r '.prefix // "WTSEC"')
    RATE=$(echo "$SEC_LOG" | jq -r '.rate // "10/second"')

    uci set firewall.@defaults[0].log="$([ "$EN" = "true" ] && echo 1 || echo 0)"
    uci set firewall.@defaults[0].log_level="$LVL"
    uci set firewall.@defaults[0].log_limit="$RATE"
    uci set firewall.@defaults[0].log_prefix="$PFX"
    uci commit firewall
    /etc/init.d/firewall restart

    mkdir -p /etc/wiretide
    echo "$PFX" > /etc/wiretide/fw_log_prefix
    log "Applied security logging: enabled=$EN level=$LVL prefix=$PFX rate=$RATE"
  fi

  opkg update
  echo "$PKG_JSON" | jq -r '.apps[]?' | while IFS= read -r app; do
    if [ -n "$(opkg list-installed "$app" 2>/dev/null)" ]; then
      log "$app already installed"
    else
      log "Installing app: $app"
      if opkg install "$app"; then
        VERSION="$(opkg list-installed "$app" | awk '{print $3}')"
        log "Installed: $app (version $VERSION)"
      else
        log "Failed to install: $app"
      fi
    fi
  done

  DHCP_CONFIG="$(echo "$PKG_JSON" | jq -c '.dhcp // {}')"
  if echo "$DHCP_CONFIG" | jq -e 'to_entries | length > 0' >/dev/null 2>&1; then
    echo "$DHCP_CONFIG" | jq -r 'to_entries[] | "uci set dhcp.@dnsmasq[0].\(.key)=\"\(.value)\""' | sh
    uci commit dhcp && /etc/init.d/dnsmasq restart && log "DHCP config updated"
  fi
}

log "Starting Wiretide agent (Controller: $CONTROLLER_URL, MAC: $MAC)"
register_device

while [ ! -f "$TOKEN_FILE" ]; do
  fetch_token
  [ -f "$TOKEN_FILE" ] || sleep "$POLL_DELAY"
done

while true; do
  send_status
  handle_package
  if [ ! -f "$TOKEN_FILE" ]; then
    while [ ! -f "$TOKEN_FILE" ]; do
      fetch_token
      [ -f "$TOKEN_FILE" ] || sleep "$POLL_DELAY"
    done
  fi
  sleep "$INTERVAL"
done

