#!/bin/sh
# Wiretide Agent – full production + client reporting
# Version: 2025.08.20-fwsec13
# Preserves all fwsec11 functions; adds register + robust token bootstrap

VERSION="Wiretide Agent v2025.08.14-fwsec12b"
LOG_FILE="/tmp/wiretide-debug.log"
INTERVAL="${INTERVAL:-60}"
CA_CERT="${CA_CERT:-/etc/wiretide-ca.crt}"
CTRL_FILE="/etc/wiretide-controller"
TOKEN_FILE="/etc/wiretide-token"
CONF_FILE="/etc/wiretide/agent.conf"
FW_PROFILE_FILE="/etc/wiretide/firewall_profile_active"
FW_PREFIX_FILE="/etc/wiretide/fw_log_prefix"
PAYLOAD_FILE="/tmp/wiretide-last-payload.json"
SEC_PREFIX_DEFAULT="WTSEC"

CURL_OPTS_COMMON="-s --connect-timeout 5 --max-time 15"
[ -s "$CA_CERT" ] && CURL_OPTS_COMMON="$CURL_OPTS_COMMON --cacert $CA_CERT" || CURL_OPTS_COMMON="$CURL_OPTS_COMMON -k"

log() {
  ts="[$(date '+%Y-%m-%d %H:%M:%S')]"
  echo "$ts $*" >> "$LOG_FILE"
}

normalize_mac() { echo "$1" | tr 'A-F' 'a-f'; }

read_conf_if_exists() {
  [ -s "$CONF_FILE" ] || return 0
  . "$CONF_FILE" 2>/dev/null || true
}

get_mac() {
  if [ -n "${MAC:-}" ]; then echo "$(normalize_mac "$MAC")"; return; fi
  mac="$(uci -q get network.lan.macaddr 2>/dev/null)"; [ -n "$mac" ] && { echo "$(normalize_mac "$mac")"; return; }
  [ -r /sys/class/net/br-lan/address ] && { cat /sys/class/net/br-lan/address; return; }
  ip link show dev eth0 2>/dev/null | awk '/ether/{print $2; exit}';
}

sha256_str() {
  if command -v sha256sum >/dev/null 2>&1; then
    printf '%s' "$1" | sha256sum | awk '{print $1}'
  elif command -v openssl >/dev/null 2>&1; then
    printf '%s' "$1" | openssl dgst -sha256 | awk '{print $2}'
  else
    echo ""
  fi
}

verify_pkg_sha() {
  pkg_json_str="$1"   # lege string toegestaan
  sha_srv="$2"
  pkg_obj_compact="$3"  # compacte objectstring of leeg

  [ -z "$sha_srv" ] && { log "⚠️ No sha256 in config; skipping verification"; return 0; }

  # 1) raw string hash
  if [ -n "$pkg_json_str" ]; then
    h_raw="$(sha256_str "$pkg_json_str")"
    [ "$h_raw" = "$sha_srv" ] && { log "✅ Package SHA256 OK (raw string)"; return 0; }
  fi

  # 2) canonicalized string hash
  if [ -n "$pkg_json_str" ] && command -v jq >/dev/null 2>&1; then
    canon_str="$(printf '%s' "$pkg_json_str" | jq -cS '.' 2>/dev/null || printf '%s' "$pkg_json_str")"
    h_canon_str="$(sha256_str "$canon_str")"
    [ "$h_canon_str" = "$sha_srv" ] && { log "✅ Package SHA256 OK (canon string)"; return 0; }
  fi

  # 3) canonicalized object hash
  if [ -n "$pkg_obj_compact" ] && command -v jq >/dev/null 2>&1; then
    canon_obj="$(printf '%s' "$pkg_obj_compact" | jq -cS '.' 2>/dev/null || printf '%s' "$pkg_obj_compact")"
    h_canon_obj="$(sha256_str "$canon_obj")"
    [ "$h_canon_obj" = "$sha_srv" ] && { log "✅ Package SHA256 OK (object)"; return 0; }
  fi

  log "❌ Package SHA mismatch; skipping (srv=$sha_srv)"
  return 1
}


get_hostname() {
  uci -q get system.@system[0].hostname 2>/dev/null || uname -n
}

get_wan_ip() {
  dev="$(ip route get 1.1.1.1 2>/dev/null | awk '/dev/{for(i=1;i<=NF;i++){if($i=="dev"){print $(i+1); exit}}}')"
  [ -n "$dev" ] && ip -4 addr show "$dev" 2>/dev/null | awk '/inet /{print $2}' | cut -d/ -f1 && return
  wanif="$(uci -q get network.wan.ifname 2>/dev/null)"
  [ -n "$wanif" ] && ip -4 addr show "$wanif" 2>/dev/null | awk '/inet /{print $2}' | cut -d/ -f1
}

get_dns_list() {
  file="/tmp/resolv.conf.d/resolv.conf.auto"
  [ -s "$file" ] || file="/tmp/resolv.conf.auto"
  [ -s "$file" ] || file="/etc/resolv.conf"
  if command -v jq >/dev/null 2>&1; then
    awk '/^nameserver/{print $2}' "$file" 2>/dev/null | jq -R . | jq -cs .
  else
    # minimal JSON array zonder jq
    awk '/^nameserver/{print $2}' "$file" 2>/dev/null | paste -sd ',' - | sed 's/^$/[]/; s/\([^,][^,]*\)/"&"/g; s/^/[/' | sed 's/$/]/'
  fi
}

is_ntp_synced() {
  year=$(date +%Y 2>/dev/null)
  if [ "$year" -ge 2020 ]; then echo true; else echo false; fi
}

json_escape() { sed 's/\\/\\\\/g; s/"/\\\"/g'; }

security_log_samples_json() {
  prefix="$(cat "$FW_PREFIX_FILE" 2>/dev/null)"; [ -n "$prefix" ] || prefix="$SEC_PREFIX_DEFAULT"
  if command -v jq >/dev/null 2>&1; then
    logread -l 400 2>/dev/null | grep "$prefix" | tail -n 20 | jq -R -s 'split("\n") | map(select(length>0))'
  else
    # fallback: leeg array
    printf '[]'
  fi
}

list_clients_json() {
  out="[]"
  tmp="/tmp/.wt-clients.$$"
  : > "$tmp"
  # DHCP leases
  if [ -f /tmp/dhcp.leases ]; then
    awk '{
      ip=$3; mac=$2; name=$4;
      if (ip && mac) printf "%s %s %s\n", ip, mac, name
    }' /tmp/dhcp.leases > "$tmp"
  fi
  # ARP toevoegen als niet in DHCP
  arp -n 2>/dev/null | awk 'NR>1{print $1" "$3}' | while read -r ip mac; do
    [ -z "$mac" ] && continue
    grep -qi " $mac " "$tmp" || echo "$ip $mac -" >> "$tmp"
  done
  # Bouw JSON
  if command -v jq >/dev/null 2>&1; then
    out="$(awk '{printf("{\"ip\":\"%s\",\"mac\":\"%s\",\"hostname\":\"%s\"}\n",$1,$2,$3)}' "$tmp" | jq -s '.')"
  else
    out="["$(awk '{printf("{\"ip\":\"%s\",\"mac\":\"%s\",\"hostname\":\"%s\"},",$1,$2,$3)}' "$tmp" | sed 's/,$//')"]"
    [ "$out" = "[]" ] || true
  fi
  rm -f "$tmp"
  echo "${out:-[]}"
}

build_payload() {
  ssh_enabled=false
  pgrep dropbear >/dev/null && [ -s /etc/dropbear/dropbear_rsa_host_key ] && ssh_enabled=true

  dns_json="$(get_dns_list)"; [ -n "$dns_json" ] || dns_json="[]"
  sec_json="$(security_log_samples_json)"; [ -n "$sec_json" ] || sec_json="[]"
  clients_json="$(list_clients_json)"; [ -n "$clients_json" ] || clients_json="[]"

  model="$(cat /tmp/sysinfo/model 2>/dev/null)"; [ -n "$model" ] || model="unknown"
  ntp_ok="$(is_ntp_synced)"

  fw_profile_active="unknown"
  if [ -f "$FW_PROFILE_FILE" ]; then
    fw_profile_active="$(cat "$FW_PROFILE_FILE" | tr -d '\r\n')"
    [ -z "$fw_profile_active" ] && fw_profile_active="unknown"
  fi

  cat <<JSON > "$PAYLOAD_FILE"
{
  "mac": "$MAC",
  "hostname": "$HOSTNAME",
  "device_type": "$DEVICE_TYPE",
  "ssh_enabled": $ssh_enabled,
  "settings": {
    "model": "$(echo "$model" | json_escape)",
    "wan_ip": "$(echo "$(get_wan_ip)" | json_escape)",
    "dns": $dns_json,
    "ntp": $ntp_ok,
    "firewall": true,
    "firewall_profile": "$(echo "$fw_profile_active" | json_escape)",
    "security_log_samples": $sec_json,
    "agent_version": "$VERSION"
  },
  "clients": $clients_json
}
JSON
}



register_device() {
  ssh_fp="unknown"
  if [ -f /etc/dropbear/dropbear_rsa_host_key ] && command -v dropbearkey >/dev/null 2>&1; then
    ssh_fp="$(dropbearkey -y -f /etc/dropbear/dropbear_rsa_host_key 2>/dev/null | awk '/Fingerprint/{print $2}')"
  fi
  body="$(cat <<JSON
{"hostname":"$HOSTNAME","mac":"$MAC","ssh_fingerprint":"$ssh_fp","ssh_enabled":true}
JSON
)"
  log "Registering device..."
  code=$(echo "$body" | curl $CURL_OPTS_COMMON -o /dev/null -w '%{http_code}' \
         -H "Content-Type: application/json" \
         -X POST "$CONTROLLER_URL/register" --data @- 2>/dev/null || true)
  log "Register response: HTTP $code"
}

fetch_token() {
  log "Fetching token from controller..."
  resp="$(curl $CURL_OPTS_COMMON -w '\n%{http_code}\n' "$CONTROLLER_URL/token/$MAC" 2>/dev/null || true)"
  code="$(printf '%s' "$resp" | tail -n1)"
  body="$(printf '%s' "$resp" | sed '$d')"

  if [ "$code" = "403" ]; then
    log "Awaiting approval (HTTP 403)."
    return 2
  fi
  if [ "$code" != "200" ]; then
    log "Token fetch failed: HTTP $code"
    return 1
  fi

  newtok="$(echo "$body" | grep -oE '"token"\s*:\s*"[^"]+"' | sed -E 's/.*"token"\s*:\s*"([^"]+)".*/\1/')"
  if [ -n "$newtok" ]; then
    umask 077
    echo "$newtok" > "$TOKEN_FILE"
    TOKEN="$newtok"
    log "New token saved"
    return 0
  else
    log "Token parse failed"
    return 1
  fi
}

send_status() {
  if [ ! -f "$TOKEN_FILE" ]; then
    fetch_token || return $?
  fi

  TOKEN="$(cat "$TOKEN_FILE" 2>/dev/null)"
  [ -n "$TOKEN" ] || { log "No token available"; return 1; }

  log "Sending status update..."
  build_payload
  [ -s "$PAYLOAD_FILE" ] || { log "❌ Payload file does not exist"; return 1; }

  BYTES=$(ls -l "$PAYLOAD_FILE" 2>/dev/null | awk '{print $5}')
  if [ -z "$BYTES" ] || [ "$BYTES" -lt 50 ]; then
    log "⚠️ Payload file too small or unreadable, skipping"
    cat "$PAYLOAD_FILE"
    return 1
  fi

  HTTP_CODE=$(curl $CURL_OPTS_COMMON -o /dev/null -w '%{http_code}' \
    -H "X-API-Token: $TOKEN" \
    -H "Content-Type: application/json" \
    -X POST "$CONTROLLER_URL/status" --data @"$PAYLOAD_FILE" || true)
  log "Status update response: HTTP $HTTP_CODE"

  if [ "$HTTP_CODE" = "403" ]; then
    log "Token rejected, attempting refresh"
    fetch_token || return 1
    TOKEN="$(cat "$TOKEN_FILE" 2>/dev/null)"
    [ -n "$TOKEN" ] || { log "Refresh failed"; return 1; }
    HTTP_CODE=$(curl $CURL_OPTS_COMMON -o /dev/null -w '%{http_code}' \
      -H "X-API-Token: $TOKEN" \
      -H "Content-Type: application/json" \
      -X POST "$CONTROLLER_URL/status" --data @"$PAYLOAD_FILE" || true)
    log "Retry status post: HTTP $HTTP_CODE"
    [ "$HTTP_CODE" = "200" ] || return 1
  elif [ "$HTTP_CODE" != "200" ]; then
    log "❌ Status post failed: HTTP $HTTP_CODE"
    log "$(cat "$PAYLOAD_FILE")"
    return 1
  fi
  return 0
}

apply_firewall_profile() {
  prof="$1"
  [ -n "$prof" ] || return 0

  src="/etc/wiretide/profiles/firewall-${prof}.conf"

  if [ "$prof" = "custom" ]; then
    echo "custom" > "$FW_PROFILE_FILE"
    log "Custom firewall profile detected — skipping apply"
    return 0
  fi

  if [ -f "$src" ]; then
    log "Applying firewall profile '$prof' from: $src"

    cp "$src" /etc/config/firewall
    sync

    /etc/init.d/firewall stop
    killall -q -9 ubusd || true
    sleep 1
    /etc/init.d/firewall start || /etc/init.d/firewall restart

    echo "$prof" > "$FW_PROFILE_FILE"
    log "Firewall profile '$prof' applied and reloaded"
  else
    log "⚠️ Profile '$prof' not found at $src — skipping"
  fi
}


ensure_security_logging_rule() {
  enabled="$1"; prefix="$2"
  [ -n "$prefix" ] && echo "$prefix" > "$FW_PREFIX_FILE"

  uci -q delete firewall.wtsec_log.extra >/dev/null 2>&1 || true
  for opt in $(uci show firewall 2>/dev/null | awk -F'=' '/\.extra=/{print $1}'); do uci -q delete "$opt"; done

  if [ "$enabled" = "true" ]; then
    uci -q delete firewall.wtsec_log
    uci set firewall.wtsec_log='rule'
    uci set firewall.wtsec_log.name='Wiretide Security Log'
    uci set firewall.wtsec_log.src='lan'
    uci set firewall.wtsec_log.proto='all'
    uci set firewall.wtsec_log.enabled='1'
    uci set firewall.wtsec_log.limit='10/second'
    uci set firewall.wtsec_log.log="${prefix:-$SEC_PREFIX_DEFAULT} "
    uci set firewall.wtsec_log.target='ACCEPT'
    uci commit firewall
    /etc/init.d/firewall reload || /etc/init.d/firewall restart
    logger "${prefix:-$SEC_PREFIX_DEFAULT} TEST: security logging active"
    log "Security logging enabled"
  else
    uci set firewall.wtsec_log.enabled='0' 2>/dev/null || true
    uci commit firewall 2>/dev/null || true
    /etc/init.d/firewall reload 2>/dev/null || true
    log "Security logging disabled"
  fi
}

apply_firewall_profile() {
  prof="$1"
  [ -z "$prof" ] && return 0

  echo "$prof" > "$FW_PROFILE_FILE"

  if [ "$prof" = "custom" ]; then
    log "Custom firewall profile active – skipping controller-managed rules"
    return 0
  fi

  conf_path="/etc/wiretide/profiles/firewall-${prof}.conf"
  if [ -f "$conf_path" ]; then
    log "Applying firewall profile '$prof' from: $conf_path"
    . "$conf_path"
    /etc/init.d/firewall reload || /etc/init.d/firewall restart
    log "Firewall profile '$prof' applied and reloaded"
  else
    log "⚠️ No matching config found: $conf_path"
  fi

  sync
}


handle_config() {
  [ ! -f "$TOKEN_FILE" ] && return 0
  TOKEN="$(cat "$TOKEN_FILE")"
  raw=$(curl $CURL_OPTS_COMMON -H "X-API-Token: $TOKEN" -H "X-MAC: $MAC" -X GET "$CONTROLLER_URL/config")
  [ -n "$raw" ] || { log "No config"; return 0; }

  command -v jq >/dev/null 2>&1 || { log "jq not present; skipping config apply"; return 0; }

  pkg_json_str=$(printf '%s' "$raw" | jq -r '.package_json // empty')
  pkg_obj_compact=$(printf '%s' "$raw" | jq -c '.package // {}')
  sha_srv=$(printf '%s' "$raw" | jq -r '.sha256 // empty')

  if ! verify_pkg_sha "$pkg_json_str" "$sha_srv" "$pkg_obj_compact"; then
    return 0
  fi

  tmpfile="/tmp/.wt-pkg.$$"

  if [ -n "$pkg_json_str" ] && [ "$pkg_json_str" != "null" ]; then
    printf '%s\n' "$pkg_json_str" > "$tmpfile"
    jq . "$tmpfile" >&2
    prof=$(jq -r '.firewall_profile // ""' "$tmpfile")
    sec_enabled=$(jq -r '.security_logging.enabled // false' "$tmpfile")
    sec_prefix=$(jq -r '.security_logging.prefix // "'"$SEC_PREFIX_DEFAULT"'"' "$tmpfile")
    apps_json="$(cat "$tmpfile")"
  else
    printf '%s\n' "$pkg_obj_compact" > "$tmpfile"
    jq . "$tmpfile" >&2
    prof=$(jq -r '.firewall_profile // ""' "$tmpfile")
    sec_enabled=$(jq -r '.security_logging.enabled // false' "$tmpfile")
    sec_prefix=$(jq -r '.security_logging.prefix // "'"$SEC_PREFIX_DEFAULT"'"' "$tmpfile")
    apps_json="$(cat "$tmpfile")"
  fi

  rm -f "$tmpfile"

  log "DEBUG: extracted prof=$prof sec_enabled=$sec_enabled sec_prefix=$sec_prefix"

  apply_firewall_profile "$prof"
  ensure_security_logging_rule "$sec_enabled" "$sec_prefix"
  apply_apps_from_pkg "$apps_json"

  log "Config applied."
  log "DEBUG: pkg_compact = $apps_json"
  return 0
}


# ========== Main ==========
lockfile="/var/run/wiretide-agent.lock"
if command -v flock >/dev/null 2>&1; then
  exec 9>"$lockfile"
  flock -n 9 || { log "Already running – exiting"; exit 0; }
else
  if [ -e "$lockfile" ]; then
    oldpid=$(cat "$lockfile" 2>/dev/null)
    [ -n "$oldpid" ] && kill -0 "$oldpid" 2>/dev/null && { log "Instance $oldpid active – exiting"; exit 0; }
  fi
  echo $$ > "$lockfile"
fi

read_conf_if_exists
CONTROLLER_URL="$(cat "$CTRL_FILE" 2>/dev/null)"
[ -n "$CONTROLLER_URL" ] || CONTROLLER_URL="https://127.0.0.1"
MAC="$(normalize_mac "$(get_mac)")"
HOSTNAME="$(get_hostname)"
DEVICE_TYPE="${DEVICE_TYPE:-router}"

log "Starting $VERSION (PID $$)"
log "Controller=$CONTROLLER_URL, MAC=$MAC, Hostname=$HOSTNAME, Interval=${INTERVAL}s"

# NEW: initial registration (idempotent)
register_device

# NEW: token bootstrap (backoff tot approval/token)
if [ ! -f "$TOKEN_FILE" ]; then
  backoff=15
  while [ ! -f "$TOKEN_FILE" ]; do
    if fetch_token; then
      break
    else
      log "No token yet; sleeping ${backoff}s"
      sleep "$backoff"
      backoff=$(( backoff * 2 ))
      [ "$backoff" -gt 300 ] && backoff=300
    fi
  done
fi

while true; do
  send_status || log "Status post failed"
  handle_config || log "Config fetch failed"
  sleep "$INTERVAL"
done

