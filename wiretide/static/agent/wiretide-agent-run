#!/bin/sh
# Wiretide Agent – resilient loop + firewall logging + timeouts
# Version: 2025.08.11-fwsec10
# Target: OpenWrt BusyBox / ash

VERSION="Wiretide Agent v2025.08.11+fwsec10"
LOG_FILE="/tmp/wiretide-debug.log"
INTERVAL="${INTERVAL:-60}"
CA_CERT="${CA_CERT:-/etc/wiretide-ca.crt}"
CTRL_FILE="/etc/wiretide-controller"
TOKEN_FILE="/etc/wiretide-token"
CONF_FILE="/etc/wiretide/agent.conf"
FW_PROFILE_FILE="/etc/wiretide/firewall_profile_active"
FW_PREFIX_FILE="/etc/wiretide/fw_log_prefix"
PAYLOAD_FILE="/tmp/wiretide-last-payload.json"
SEC_PREFIX_DEFAULT="WTSEC"

CURL_OPTS_COMMON="-s --connect-timeout 5 --max-time 15"
[ -s "$CA_CERT" ] && CURL_OPTS_COMMON="$CURL_OPTS_COMMON --cacert $CA_CERT"

log() {
  ts="[$(date '+%Y-%m-%d %H:%M:%S')]"
  echo "$ts $*" >> "$LOG_FILE"
}

normalize_mac() { echo "$1" | tr 'A-F' 'a-f'; }

read_conf_if_exists() {
  [ -s "$CONF_FILE" ] || return 0
  . "$CONF_FILE" 2>/dev/null || true
}

get_mac() {
  if [ -n "$MAC" ]; then echo "$(normalize_mac "$MAC")"; return; fi
  mac="$(uci -q get network.lan.macaddr 2>/dev/null)"; [ -n "$mac" ] && { echo "$(normalize_mac "$mac")"; return; }
  [ -r /sys/class/net/br-lan/address ] && { cat /sys/class/net/br-lan/address; return; }
  ip link show dev eth0 2>/dev/null | awk '/ether/{print $2; exit}';
}

get_hostname() {
  uci -q get system.@system[0].hostname 2>/dev/null || uname -n
}

get_wan_ip() {
  dev="$(ip route get 1.1.1.1 2>/dev/null | awk '/dev/{for(i=1;i<=NF;i++){if($i=="dev"){print $(i+1); exit}}}')"
  [ -n "$dev" ] && ip -4 addr show "$dev" 2>/dev/null | awk '/inet /{print $2}' | cut -d/ -f1 && return
  wanif="$(uci -q get network.wan.ifname 2>/dev/null)"
  [ -n "$wanif" ] && ip -4 addr show "$wanif" 2>/dev/null | awk '/inet /{print $2}' | cut -d/ -f1
}

get_dns_list() {
  if [ -s /tmp/resolv.conf.d/resolv.conf.auto ]; then
    awk '/^nameserver/{print $2}' /tmp/resolv.conf.d/resolv.conf.auto | tr '\n' ',' | sed 's/,$//'
  else
    awk '/^nameserver/{print $2}' /tmp/resolv.conf | tr '\n' ',' | sed 's/,$//'
  fi
}

is_ntp_synced() {
  year=$(date +%Y 2>/dev/null)
  if [ "$year" -ge 2020 ]; then echo true; else echo false; fi
}

json_escape() { sed 's/\\/\\\\/g; s/"/\\"/g'; }

security_log_samples_json() {
  prefix="$(cat "$FW_PREFIX_FILE" 2>/dev/null)"; [ -n "$prefix" ] || prefix="$SEC_PREFIX_DEFAULT"
  if command -v jq >/dev/null 2>&1; then
    logread -l 400 2>/dev/null | grep "$prefix" | tail -n 20 | jq -R -s 'split("\n") | map(select(length>0))'
  else
    printf '[]'
  fi
}

build_payload() {
  ssh_enabled=false
  pgrep dropbear >/dev/null && [ -s /etc/dropbear/dropbear_rsa_host_key ] && ssh_enabled=true

  dns_csv="$(get_dns_list)"
  dns_json="[]"
  [ -n "$dns_csv" ] && dns_json="[\"$(echo "$dns_csv" | sed 's/,/\",\"/g')\"]"

  sec_json="$(security_log_samples_json)"; [ -n "$sec_json" ] || sec_json="[]"

  model="$(cat /tmp/sysinfo/model 2>/dev/null)"; [ -n "$model" ] || model="unknown"
  ntp_ok="$(is_ntp_synced)"
  fw_profile_active="$(cat "$FW_PROFILE_FILE" 2>/dev/null | tr -d '\r\n')"
  [ -n "$fw_profile_active" ] || fw_profile_active="unknown"

  cat <<JSON > "$PAYLOAD_FILE"
{
  "mac": "$MAC",
  "hostname": "$HOSTNAME",
  "device_type": "$DEVICE_TYPE",
  "ssh_enabled": $ssh_enabled,
  "settings": {
    "model": "$(echo "$model" | json_escape)",
    "wan_ip": "$(echo "$(get_wan_ip)" | json_escape)",
    "dns": $dns_json,
    "ntp": $ntp_ok,
    "firewall": true,
    "firewall_profile": "$(echo "$fw_profile_active" | json_escape)",
    "security_log_samples": $sec_json
  }
}
JSON
}

fetch_token() {
  log "Fetching token from controller..."
  newtok="$(curl $CURL_OPTS_COMMON "$CONTROLLER_URL/token/$MAC" | grep -oE '"token"\s*:\s*"[^"]+"' | sed -E 's/.*"token"\s*:\s*"([^"]+)".*/\1/')"
  if [ -n "$newtok" ]; then
    echo "$newtok" > "$TOKEN_FILE"; chmod 600 "$TOKEN_FILE"
    TOKEN="$newtok"
    log "New token saved"
  else
    log "Token fetch failed"
  fi
}

send_status() {
  [ ! -f "$TOKEN_FILE" ] && return 1
  TOKEN="$(cat "$TOKEN_FILE")"
  log "Sending status update..."
  build_payload
  [ -s "$PAYLOAD_FILE" ] || { log "❌ Payload file does not exist"; return 1; }

  BYTES=$(ls -l "$PAYLOAD_FILE" 2>/dev/null | awk '{print $5}')
  if [ -z "$BYTES" ] || [ "$BYTES" -lt 50 ]; then
    log "⚠️ Payload file too small or unreadable, skipping"
    cat "$PAYLOAD_FILE"
    return 1
  fi

  HTTP_CODE=$(curl $CURL_OPTS_COMMON -o /dev/null -w '%{http_code}' \
    -H "X-API-Token: $TOKEN" \
    -H "Content-Type: application/json" \
    -X POST "$CONTROLLER_URL/status" --data @"$PAYLOAD_FILE")
  log "Status update response: HTTP $HTTP_CODE"

  if [ "$HTTP_CODE" = "403" ]; then
    log "Token rejected, attempting refresh"
    fetch_token
    TOKEN="$(cat "$TOKEN_FILE" 2>/dev/null)"
    [ -n "$TOKEN" ] || { log "Refresh failed"; return 1; }

    HTTP_CODE=$(curl $CURL_OPTS_COMMON -o /dev/null -w '%{http_code}' \
      -H "X-API-Token: $TOKEN" \
      -H "Content-Type: application/json" \
      -X POST "$CONTROLLER_URL/status" --data @"$PAYLOAD_FILE")
    log "Retry status post: HTTP $HTTP_CODE"
    [ "$HTTP_CODE" = "200" ] || return 1
  elif [ "$HTTP_CODE" != "200" ]; then
    log "❌ Status post failed: HTTP $HTTP_CODE"
    log "$(cat "$PAYLOAD_FILE")"
    return 1
  fi
  return 0
}

apply_firewall_profile() {
  prof="$1"
  [ -n "$prof" ] || return 0
  echo "$prof" > "$FW_PROFILE_FILE"
  sync
  log "Applied firewall profile: $prof"
}

ensure_security_logging_rule() {
  enabled="$1"; prefix="$2"
  [ -n "$prefix" ] && echo "$prefix" > "$FW_PREFIX_FILE"

  uci -q delete firewall.wtsec_log.extra >/dev/null 2>&1 || true
  for opt in $(uci show firewall | awk -F'=' '/\.extra=/{print $1}'); do uci -q delete "$opt"; done

  if [ "$enabled" = "true" ]; then
    uci -q delete firewall.wtsec_log
    uci set firewall.wtsec_log='rule'
    uci set firewall.wtsec_log.name='Wiretide Security Log'
    uci set firewall.wtsec_log.src='lan'
    uci set firewall.wtsec_log.proto='all'
    uci set firewall.wtsec_log.enabled='1'
    uci set firewall.wtsec_log.limit='10/second'
    uci set firewall.wtsec_log.log="${prefix:-$SEC_PREFIX_DEFAULT} "
    uci set firewall.wtsec_log.target='ACCEPT'
    uci commit firewall
    /etc/init.d/firewall reload || /etc/init.d/firewall restart
    logger "${prefix:-$SEC_PREFIX_DEFAULT} TEST: security logging active"
    log "Security logging enabled"
  else
    uci set firewall.wtsec_log.enabled='0'
    uci commit firewall
    /etc/init.d/firewall reload || true
    log "Security logging disabled"
  fi
}

handle_config() {
  [ ! -f "$TOKEN_FILE" ] && return
  TOKEN="$(cat "$TOKEN_FILE")"
  json=$(curl $CURL_OPTS_COMMON -H "X-API-Token: $TOKEN" -H "X-MAC: $MAC" -X GET "$CONTROLLER_URL/config")
  [ -n "$json" ] || { log "No config"; return 0; }

  pkg=$(echo "$json" | jq -c '.package // {}')
  [ -n "$pkg" ] || { log "No package"; return 0; }

  prof=$(echo "$pkg" | jq -r '.firewall_profile // empty')
  [ -n "$prof" ] && apply_firewall_profile "$prof"

  sec_enabled=$(echo "$pkg" | jq -r '.security_logging.enabled // false')
  sec_prefix=$(echo "$pkg" | jq -r '.security_logging.prefix // "'"$SEC_PREFIX_DEFAULT"'"')
  ensure_security_logging_rule "$sec_enabled" "$sec_prefix"
}

apply_apps() {
  [ ! -f "$TOKEN_FILE" ] && return
  TOKEN="$(cat "$TOKEN_FILE")"
  json=$(curl $CURL_OPTS_COMMON -H "X-API-Token: $TOKEN" -H "X-MAC: $MAC" -X GET "$CONTROLLER_URL/config")
  [ -z "$json" ] && { log "No config for apps"; return; }

  apps=$(echo "$json" | jq -r '.package.apps[]?' 2>/dev/null)
  [ -z "$apps" ] && return

  for app in $apps; do
    case "$app" in
      adblock|banip)
        if opkg list-installed "$app" >/dev/null 2>&1; then
          log "$app already installed"
        else
          log "Installing $app..."
          opkg update >/dev/null 2>&1
          out=$(opkg install "$app" 2>&1)
          log "$app install result:\n$out"
        fi
        ;;
      *)
        log "Ignoring unsupported app: $app"
        ;;
    esac
  done
}


# ========== Main ==========
lockfile="/var/run/wiretide-agent.lock"
if command -v flock >/dev/null 2>&1; then
  exec 9>"$lockfile"
  flock -n 9 || { log "Already running – exiting"; exit 0; }
else
  if [ -e "$lockfile" ]; then
    oldpid=$(cat "$lockfile" 2>/dev/null)
    [ -n "$oldpid" ] && kill -0 "$oldpid" 2>/dev/null && { log "Instance $oldpid active – exiting"; exit 0; }
  fi
  echo $$ > "$lockfile"
fi

read_conf_if_exists
CONTROLLER_URL="$(cat "$CTRL_FILE" 2>/dev/null)"
[ -n "$CONTROLLER_URL" ] || CONTROLLER_URL="https://127.0.0.1"
MAC="$(normalize_mac "$(get_mac)")"
HOSTNAME="$(get_hostname)"
DEVICE_TYPE="${DEVICE_TYPE:-router}"

log "Starting $VERSION (PID $$)"
log "Controller=$CONTROLLER_URL, MAC=$MAC, Hostname=$HOSTNAME, Interval=${INTERVAL}s"

while true; do
  send_status || log "Status post failed"
  handle_config || log "Config fetch failed"
  sleep "$INTERVAL"
done

