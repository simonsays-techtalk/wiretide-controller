#!/bin/sh

# Wiretide Agent (final fixed version)
# - Valid JSON client list (no trailing commas, skips bad MACs)
# - Only uses X-API-Token (no duplicate headers)
# - Auto-refetches token if invalid (403)
# - Logs for debugging

CONTROLLER_URL="$(cat /etc/wiretide-controller 2>/dev/null || echo 'https://127.0.0.1')"
CA_CERT="/etc/wiretide-ca.crt"
TOKEN_FILE="/etc/wiretide-token"
INTERVAL=60
POLL_DELAY=10
DEBUG_LOG="/tmp/wiretide-debug.log"
PAYLOAD_FILE="/tmp/wiretide-last-payload.json"

# Determine primary interface + MAC
IFACE=""
[ -d /sys/class/net/br-lan ] && IFACE="br-lan"
[ -z "$IFACE" ] && IFACE="$(ip route | awk '/default/ {print $5}' | head -n1)"
[ -z "$IFACE" ] && IFACE="$(ip -o link show | awk -F': ' '/state UP/ && $2!="lo"{print $2;exit}')"
MAC="$(ip link show "$IFACE" 2>/dev/null | awk '/ether/ {print $2}')"
DEVICE_IP="$(ip -4 addr show "$IFACE" 2>/dev/null | awk '/inet /{print $2}' | cut -d/ -f1)"
MODEL="$(cat /tmp/sysinfo/model 2>/dev/null)"
FPR="$(dropbearkey -y -f /etc/dropbear/dropbear_rsa_host_key 2>/dev/null | awk -F': ' '/Fingerprint/ {print $2}')"

# Resolve hostname (fallback to MAC)
HOSTNAME="$(uci get system.@system[0].hostname 2>/dev/null || hostname 2>/dev/null)"
[ -z "$HOSTNAME" ] && HOSTNAME="$MAC"

log() {
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >> "$DEBUG_LOG"
}

build_payload() {
  SSH_ENABLED=false
  pgrep dropbear >/dev/null && [ -s /etc/dropbear/dropbear_rsa_host_key ] && SSH_ENABLED=true

  # Collect DNS servers
  DNS_RAW="$(uci get dhcp.@dnsmasq[0].server 2>/dev/null || grep '^nameserver' /tmp/resolv.conf | awk '{print $2}')"
  DNS_LIST=""
  for ip in $DNS_RAW; do
    ip="$(echo "$ip" | tr -d '"')"
    [ -n "$DNS_LIST" ] && DNS_LIST="$DNS_LIST, \"$ip\"" || DNS_LIST="\"$ip\""
  done

  # Firewall + NTP
  /etc/init.d/firewall enabled && /etc/init.d/firewall status >/dev/null && FIREWALL=true || FIREWALL=false
  NTP="$(uci get system.ntp.enabled 2>/dev/null || echo false)"

  CLIENTS=""
  SEEN="/tmp/wt-seen-macs"; > "$SEEN"

  add_client() {
    # Validate MAC address format
    echo "$1" | grep -Eq '^([0-9a-f]{2}:){5}[0-9a-f]{2}$' || return
    [ -n "$CLIENTS" ] && CLIENTS="$CLIENTS,"
    CLIENTS="$CLIENTS{ \"mac\":\"$1\",\"ip\":\"$2\",\"hostname\":\"$3\",\"interface\":\"$4\",\"connected_via\":\"$5\",\"rx_bytes\":0,\"tx_bytes\":0 }"
  }

  # Wi-Fi stations
  iw dev 2>/dev/null | awk '/Interface/{print $2}' > /tmp/wt-if
  while read -r ifc; do
    iw dev "$ifc" station dump | awk '/Station/{print $2}' | tr 'A-Z' 'a-z' > /tmp/wt-wifi
    while read -r sta; do
      echo "$sta" >> "$SEEN"
      add_client "$sta" "unknown" "unknown" "$ifc" "wifi"
    done < /tmp/wt-wifi
  done < /tmp/wt-if
  rm -f /tmp/wt-if /tmp/wt-wifi

  # DHCP leases
  [ -f /tmp/dhcp.leases ] && awk '{print tolower($2)","$3","$4}' /tmp/dhcp.leases | \
  while IFS=, read -r cm cip ch; do
    echo "$cip" | grep -q '^fe80::' && continue
    grep -q "$cm" "$SEEN" && continue
    echo "$cm" >> "$SEEN"
    [ -z "$ch" ] && ch="unknown"
    add_client "$cm" "$cip" "$ch" "unknown" "ethernet"
  done

  # ARP neighbors
  ip neigh show | awk '{print tolower($1)","tolower($5)}' > /tmp/wt-arp
  while IFS=, read -r ip mac; do
    echo "$ip" | grep -q '^fe80::' && continue
    grep -q "$mac" "$SEEN" && continue
    echo "$mac" >> "$SEEN"
    add_client "$mac" "$ip" "unknown" "unknown" "ethernet"
  done < /tmp/wt-arp
  rm -f /tmp/wt-arp "$SEEN"

  SETTINGS=$(cat <<EOF
{ "model":"$MODEL","wan_ip":"$DEVICE_IP","dns":[ $DNS_LIST ],"firewall":$FIREWALL,"ntp":$NTP }
EOF
)

  cat <<EOF > "$PAYLOAD_FILE"
{
  "hostname":"$HOSTNAME",
  "mac":"$MAC",
  "ssh_fingerprint":"$FPR",
  "ssh_enabled":$SSH_ENABLED,
  "settings":$SETTINGS,
  "clients":[ $CLIENTS ]
}
EOF
}

register_device() {
  SSH_ENABLED=false
  pgrep dropbear >/dev/null && [ -s /etc/dropbear/dropbear_rsa_host_key ] && SSH_ENABLED=true
  JSON="{\"hostname\":\"$HOSTNAME\",\"mac\":\"$MAC\",\"ssh_fingerprint\":\"$FPR\",\"ssh_enabled\":$SSH_ENABLED}"
  log "Registering device (hostname: $HOSTNAME)"
  curl --cacert "$CA_CERT" -s -X POST "$CONTROLLER_URL/register" \
       -H "Content-Type: application/json" -d "$JSON" >/dev/null 2>&1
}

fetch_token() {
  log "Requesting token for MAC: $MAC"
  RESPONSE="$(curl --path-as-is --cacert "$CA_CERT" -s -w '\n%{http_code}' "$CONTROLLER_URL/token/$MAC")"
  BODY="$(printf '%s\n' "$RESPONSE" | head -n1)"
  CODE="$(printf '%s\n' "$RESPONSE" | tail -n1)"
  log "Token HTTP code: $CODE"
  log "Token body: $BODY"
  if [ "$CODE" = "200" ]; then
    TOKEN="$(echo "$BODY" | grep -oE '"token"\s*:\s*"[^"]+"' | sed -E 's/.*"token"\s*:\s*"([^"]+)".*/\1/')"
    log "Parsed token: '$TOKEN'"
    if [ -n "$TOKEN" ]; then
      echo "$TOKEN" > "$TOKEN_FILE"; chmod 600 "$TOKEN_FILE"
      log "Token saved"
    else
      log "Empty token – will retry"; rm -f "$TOKEN_FILE"
    fi
  else
    log "Token fetch failed, waiting..."; rm -f "$TOKEN_FILE"
  fi
}

send_status() {
  [ ! -f "$TOKEN_FILE" ] && return 1
  TOKEN="$(cat "$TOKEN_FILE")"
  log "Sending status update..."
  build_payload
  HTTP_CODE=$(curl --cacert "$CA_CERT" -s -o /dev/null -w '%{http_code}' \
               -H "X-API-Token: $TOKEN" \
               -H "Content-Type: application/json" \
               -X POST "$CONTROLLER_URL/status" \
               -d @"$PAYLOAD_FILE")
  log "Status update response: HTTP $HTTP_CODE"
  if [ "$HTTP_CODE" = "403" ]; then
    log "Token invalid – clearing and refetching"
    rm -f "$TOKEN_FILE"
  elif [ "$HTTP_CODE" != "200" ]; then
    log ">>> Payload causing failure:"
    log "$(cat "$PAYLOAD_FILE")"
  fi
}

log "Starting Wiretide agent (Controller: $CONTROLLER_URL, MAC: $MAC)"

# Register device
register_device

# Fetch token until approved
while [ ! -f "$TOKEN_FILE" ]; do
  fetch_token
  [ -f "$TOKEN_FILE" ] || sleep "$POLL_DELAY"
done

# Main loop
while true; do
  send_status
  if [ ! -f "$TOKEN_FILE" ]; then
    # Refetch token if cleared due to 403
    while [ ! -f "$TOKEN_FILE" ]; do
      fetch_token
      [ -f "$TOKEN_FILE" ] || sleep "$POLL_DELAY"
    done
  fi
  sleep "$INTERVAL"
done

